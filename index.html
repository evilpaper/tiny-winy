<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Super Mario</title>
    <style>
        * { 
            overflow: hidden
        }
        body {
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
       canvas {
           border: 1px solid coral;
       }
    </style>
</head>
<body>
    <canvas id="a"></canvas>
    <script>
        const canvas = document.getElementById("a");
        const c = canvas.getContext("2d");

        top.reload = () => {
            location = location;
        }

        a.width = 15 * 9;
        a.height = 13 * 9;

        let l = 0;
        let u = 0;
        let r = 0;

        const map = [];
        let scroll = 0;
        let vy = 0;
        let end = 0;
        const n = 9;
        let x = 2;
        let y = 2;
        let intro = 24;
        let enemy = 24;
        let grounded = 0;

        // Helpers
        // -------
        // This function adds a pipe (id = 4) on the map starting at the given top-left position.
        // The pipe will be 2px wide and as high as needed to touch the ground at y = 11.
        const pipe = (x,y) => {
            for(let Y = 11; Y > y; Y--) {
                map[Y][x] = map[Y][x+1] = 4;
            }
        }


        const stair = (y, x, right) => {
            for (let Y = 11; Y > y; Y--) {
                if (right) {
                    for (X = x; X < x + Y - y; X++) {
                        map[Y][X] = map[10][198] = 1;
                    }
                } else {
                    for (X = x; X > x - Y + y; X--) {
                        map[Y][X] = map[10][198] = 1;
                    }
                }
            } 
        }

        // This function detects and responds to collision between a corner of Mario's pixel and other locks of the map.
        // The 'up' parameter is set if Mario is jumping and means that the collision that is being checked is between Mario's top and a block above him.

        const collision = (x, y, up) => {

            // ~~ is a double NOT bitwise operator. It is used as a faster substitute for Math.floor() for positive numbers.
            if (map[~~y]) {

                // If the map actually has a line at the given Y coordinate.
                // This must be checked because Mario can jump above and fall below the map.
                if (up && map[~~y][~~x] && map[~~y][~~x] != 2) {
                    map[~~y][~~x]--, vy = 0;
                }
            return map[~~y][~~x];
            }
        }

        // MAP
        // ---
        // Define a 211 * 15 grid with 10 lines of sky (i = 0) and 5 lines of ground (id = 1).
        // The ground has 3 holes (id = 0) at coordinates x = 69 & 70, 86 & 87 & 88, 153 & 154.
        for (let i = 14; i >= 0; i--) {
            map[i] = [];
            for (let j = 210; j >= 0; j--) {
                map[i][j] = (i > 10 && ![69, 70, 86, 87, 88, 153, 154].includes(j));
            }
        }

        // Set all the question blocks (id = 3) and brick blocks (id = 1) on the 4th and 8th lines.
        for(i of[22,94,109,129,130]) map[3][i] = 3;
        for(i of[80,81,82,83,84,85,86,87,91,92,93,121,122,123,128,131]) map[3][i] = 1;
        for(i of[8,21,23,78,106,109,112,170]) map[7][i] = 3;
        for(i of[20,22,24,77,79,94,100,118,129,130,88,89,171]) map[7][i] = map[10][198] = 1;
        
        // Set all the pipes.
        pipe(9, 28);
        pipe(8, 38);
        pipe(7, 46);
        pipe(7, 57);
        pipe(9, 83);
        pipe(9, 179);

        // Set all the stairs
        // After the first stair, two pair of stairs have a 1px difference (x = 152 & 153, x = 190 & 191).
        // This is because those those stairs have a 2px-wide platform on top.
        // It was simpler to overlap two stairs than adding a column of pixels.
        stair(6, 138);
        stair(6, 152);
        stair(6, 153);
        stair(2, 190);
        stair(2, 191);
        stair(6, 140, 1);
        stair(6, 155, 1);

        // Input 
        // -----
        // Every time a key is pressed (onkeydown) the corresponding flag is set to "w" (the 5th char of e.type = "keydown")
        // Every time a key is released (onkeyup) it is set to "undefined" (the 5th character of e.type = "keyup")
        // Those flags can be tested as if they were booleans because "w" is truthy and undefined is falsy
        // onkeydown = onkeyup = e => self['lur'[e.which - 37]] = e.type[5];
        // self refers to window.self.
        // lur must stand for left, up, right
        // The which property of the KeyboardEvent interface returns the numeric keycode of the keypressed. The code determines which key was pressed.
        // keycodes for l = 37, u = 38, r = 39, subtracting with 37 will result in 39, 48, 45 and ['lur'[e.which - 37]] will evaluate to undefined
        // The type property of the Event returns a string containing the events type
        // If the event is onkeyup e.type = "keyup" then e.type[5] = undefined (There is character at the 6th position in keyup, zero based counting, remember)
        // If the event is onkeydown e.type = "keydown" then e.type[5] = "w"

        document.addEventListener("keydown", (event) => {
            if (event.which === 37) l = 1;
            if (event.which === 38) u = 1;
            if (event.which === 39) r = 1;
        })

        // Game loop
        // ---------
        z = setInterval(

        // The game is updated and the canvas is redrawn every 9ms:
        e => {

        // Move the enemy to the left.
        enemy -= .02;

        // If the distance between the enemy and Mario is smaller than 1px:
        if(Math.hypot(enemy - x, 10 - y) < 1){

            // If Mario is jumping, "kill" the enemy by moving it at x=-1px, out of the viewport.
            if(grounded){
            enemy = -1;
            vy = -.2;
            }

            // If mario is grounded, game over.
            else {
            end = 1;
            }
        }

        // Mario goes left if `l` is set and if his position on the map is larger than the map scroll.
        if(l && x > scroll){
            x -= .1;

            // Stop Mario if he hits a solid block on the left.
            // To stop Mario precisely against the wall, his x coordinate is floored and incremented (i.e. set to the block's x + 1).
            if(collision(x, y)){
            x = ~~x + 1;
            }
        }

        // Mario goes right if `r` is set.
        if(r){
            x += .1;

            // Stop Mario if he hits a solid block on the right.
            // his x coordinate is set to the block's x - 1.1 (if it was just 1, it would continue to collide and cause bugs on the next frame).
            if(collision(x + 1, y)){
            x = ~~x - .1;
            }

            // Make the map scroll if Mario goes further than the current scroll value + 7px.
            else if(x > scroll + 7){
            scroll += .1;
            }
        }

        // Mario jumps if `u` is set and if Mario is currently touching the ground.
        // The jump is made by setting his vertical speed to -.25 pixels/frame.
        if(u && !grounded){
            vy = -.25;
        }

        // Add gravity (.012px/frame) to Mario's vertical speed and the vertical speed to the vertical position.
        vy += .012;
        y += vy;

        // During a jump (if the vertical speed has been set to a negative value):
        if(vy < 0){

            // Add vertical speed to y position
            y += vy;

            // If a solid block is hit by Mario's top-left corner or top-right corner:
            if(collision(x, y, 1) | collision(x + .9, y, 1)){

            // Place Mario just below the solid block.
            y = ~~y + 1;

            // Cancel his vertical speed.
            vy = 0;
            }
        }

        // If Mario dies by falling in a hole, or wins by touching the flag, game over
        if(y > 14 || x > 198) end = 1;

        // Stop Mario's fall when his bottom-left corner or bottom-right corner touches a solid block.
        // He is considered "grounded" and the "up" flag is unset to avoid jumping again immediately.
        // Though, Mario will continue jumping as long as no other key is pressed because the onkeydown event will be fired continuously.
        grounded = u = !(collision(x, y + 1) | collision(x + .5, y + 1));
        if(!grounded) y = ~~y, vy = 0;

        // Draw the scene:

        // Sky
        c.fillStyle = `#59f`;
        c.fillRect(0, 0, 999, 999);

        // Map
        for(i = 13; i--;){
            for(j = 999; j--;){

            // This commented code would have drawn all the clouds in white if there were enough bytes left.
            /*
            if(j%48 == 9){
                c.fillStyle=`#fff`;
                c.fillRect(j*n-scroll*n,2*n,n,n);
                c.fillRect((j+19)*n-scroll*n,2*n,3*n,n);
                c.fillRect((j+11)*n-scroll*n,n,n,n);
                c.fillRect((j+26)*n-scroll*n,n,2*n,n);
            }
            */

            // Pipes
            if(map[i][j] == 4){
                c.fillStyle = `#8d1`;
                c.fillRect(j * n - scroll * n, i * n, n, n);

                // Reuse the pipes' color to draw the flag between the lines 2 and 11 at x = 198.
                c.fillRect(198 * n + 2 - scroll * n, n, 2, 9 * n);
            }

            // Question blocks
            else if(map[i][j] == 3){
                c.fillStyle = `#f93`;
                c.fillRect(j * n - scroll * n, i * n, n, n);
            }

            // Ground / brick / stairs
            else if(map[i][j]){
                c.fillStyle = `#c40`;
                c.fillRect(j * n - scroll * n, i * n, n, n);
            }
            }
        }

        // Enemy
        c.fillStyle = `#a00`;
        c.fillRect(enemy * n - scroll * n, 10 * n, n, n);

        // Mario
        c.fillStyle = `#d20`;
        c.fillRect(x * n - scroll * n, y * n, n, n);

        // Reload the page after a game over (win / lose)
        if(end){
            top.reload();
        }

        // Draw a black screen during the intro (24 frames)
        // (It also serves as a transition after a game over)
        if(intro){
            c.fillStyle = `#000`;
            c.fillRect(0, 0, 999, 999);
            intro--;
        }
        }, 9
        )

        // After minification, some manual optimizations were added:
        // - l=u=r=0;var f=[],e=0,o=0,t=0,n=2,R=2,S=24,a=24 => f=[l=u=r=e=o=t=0],n=R=2,S=a=24
        // - grounded => z
        // - " => `
        // - replace the function in setInterval with a string
        // The minified size is 1507b.
        // After RegPacking with the score 1/0/0 and the vars a and c ignored, the size is 1018b.

    </script>
</body>
</html>